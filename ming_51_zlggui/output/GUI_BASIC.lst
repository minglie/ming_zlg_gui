C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE GUI_BASIC
OBJECT MODULE PLACED IN .\output\GUI_BASIC.obj
COMPILER INVOKED BY: D:\Program Files\keil\C51\BIN\C51.EXE src\GUI_BASIC.C LARGE BROWSE INCDIR(.\head;.\src) DEBUG OBJEC
                    -TEXTEND PRINT(.\output\GUI_BASIC.lst) TABS(2) OBJECT(.\output\GUI_BASIC.obj)

line level    source

   1          /****************************************************************************************
   2          * 文件名：GUI_BASIC.C
   3          * 功能：GUI基本绘图函数。进行基本绘图运算，并调用相应的刷新程序更新LCD显示。
   4          * 作者：黄绍斌
   5          * 日期：2004.02.26
   6          * 备注：图形操作层，进行各种图形运算操作。
   7          ****************************************************************************************/
   8          #include "config.h"
   9          #include <math.h>
  10          
  11          #if GUI_Basic_EN==1
  12          /****************************************************************************
  13          * 名称：GUI_Rectangle()
  14          * 功能：画矩形。
  15          * 入口参数： x0   矩形左上角的x坐标值
  16          *           y0    矩形左上角的y坐标值
  17          *           x1      矩形右下角的x坐标值
  18          *           y1      矩形右下角的y坐标值
  19          *           color 显示颜色
  20          * 出口参数：无
  21          * 说明：操作失败原因是指定地址超出有效范围。
  22          ****************************************************************************/
  23          void  GUI_Rectangle(uint32 x0, uint32 y0, uint32 x1, uint32 y1, TCOLOR color)
  24          {  GUI_HLine(x0, y0, x1, color);
  25   1         GUI_HLine(x0, y1, x1, color);
  26   1         GUI_RLine(x0, y0, y1, color);
  27   1         GUI_RLine(x1, y0, y1, color);
  28   1      }
  29          
  30          
  31          /****************************************************************************
  32          * 名称：GUI_RectangleFill()
  33          * 功能：填充矩形。画一个填充的矩形，填充色与边框色一样。
  34          * 入口参数： x0   矩形左上角的x坐标值
  35          *           y0    矩形左上角的y坐标值
  36          *           x1      矩形右下角的x坐标值
  37          *           y1      矩形右下角的y坐标值
  38          *           color 填充颜色
  39          * 出口参数：无
  40          * 说明：操作失败原因是指定地址超出有效范围。
  41          ****************************************************************************/
  42          void  GUI_RectangleFill(uint32 x0, uint32 y0, uint32 x1, uint32 y1, TCOLOR color)
  43          {  uint32  i;
  44   1      
  45   1         /* 先找出矩形左上角与右下角的两个点，保存在(x0,y0)，(x1,y1) */
  46   1         if(x0>x1)            // 若x0>x1，则x0与x1交换
  47   1         {  i = x0;
  48   2            x0 = x1;
  49   2            x1 = i;
  50   2         }
  51   1         if(y0>y1)            // 若y0>y1，则y0与y1交换
  52   1         {  i = y0;
  53   2            y0 = y1;
  54   2            y1 = i;
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 2   

  55   2         }
  56   1         
  57   1         /* 判断是否只是直线 */
  58   1         if(y0==y1) 
  59   1         {  GUI_HLine(x0, y0, x1, color);
  60   2            return;
  61   2         }
  62   1         if(x0==x1) 
  63   1         {  GUI_RLine(x0, y0, y1, color);
  64   2            return;
  65   2         }
  66   1      
  67   1         while(y0<=y1)            
  68   1         {  GUI_HLine(x0, y0, x1, color); // 当前画水平线
  69   2            y0++;             // 下一行
  70   2         }
  71   1      }
  72          
  73          
  74          /****************************************************************************
  75          * 名称：GUI_Square()
  76          * 功能：画正方形。
  77          * 入口参数： x0   正方形左上角的x坐标值
  78          *           y0    正方形左上角的y坐标值
  79          *           with    正方形的边长
  80          *           color 显示颜色
  81          * 出口参数：无
  82          * 说明：操作失败原因是指定地址超出有效范围。
  83          ****************************************************************************/
  84          void  GUI_Square(uint32 x0, uint32 y0, uint32  with, TCOLOR  color)
  85          {   if(with==0) return;
  86   1        if( (x0+with) > GUI_LCM_XMAX ) return;
  87   1        if( (y0+with) > GUI_LCM_YMAX ) return;
  88   1        GUI_Rectangle(x0, y0, x0+with, y0+with, color);
  89   1      }
  90          
  91          
  92          
  93          /****************************************************************************
  94          * 名称：GUI_Line()
  95          * 功能：画任意两点之间的直线。
  96          * 入口参数： x0   直线起点的x坐标值
  97          *           y0    直线起点的y坐标值
  98          *           x1      直线终点的x坐标值
  99          *           y1      直线终点的y坐标值
 100          *           color 显示颜色(对于黑白色LCM，为0时灭，为1时显示)
 101          * 出口参数：无
 102          * 说明：操作失败原因是指定地址超出有效范围。
 103          ****************************************************************************/
 104          void  GUI_Line(uint32 x0, uint32 y0, uint32 x1, uint32 y1, TCOLOR color)
 105          {  int32   dx;            // 直线x轴差值变量
 106   1         int32   dy;                // 直线y轴差值变量
 107   1         int8    dx_sym;          // x轴增长方向，为-1时减值方向，为1时增值方向
 108   1         int8    dy_sym;          // y轴增长方向，为-1时减值方向，为1时增值方向
 109   1         int32   dx_x2;         // dx*2值变量，用于加快运算速度
 110   1         int32   dy_x2;         // dy*2值变量，用于加快运算速度
 111   1         int32   di;            // 决策变量
 112   1         
 113   1         
 114   1         dx = x1-x0;            // 求取两点之间的差值
 115   1         dy = y1-y0;
 116   1         
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 3   

 117   1         /* 判断增长方向，或是否为水平线、垂直线、点 */
 118   1         if(dx>0)             // 判断x轴方向
 119   1         {  dx_sym = 1;         // dx>0，设置dx_sym=1
 120   2         }
 121   1         else
 122   1         {  if(dx<0)
 123   2            {  dx_sym = -1;       // dx<0，设置dx_sym=-1
 124   3            }
 125   2            else
 126   2            {  // dx==0，画垂直线，或一点
 127   3               GUI_RLine(x0, y0, y1, color);
 128   3               return;
 129   3            }
 130   2         }
 131   1         
 132   1         if(dy>0)             // 判断y轴方向
 133   1         {  dy_sym = 1;         // dy>0，设置dy_sym=1
 134   2         }
 135   1         else
 136   1         {  if(dy<0)
 137   2            {  dy_sym = -1;       // dy<0，设置dy_sym=-1
 138   3            }
 139   2            else
 140   2            {  // dy==0，画水平线，或一点
 141   3               GUI_HLine(x0, y0, x1, color);
 142   3               return;
 143   3            }
 144   2         }
 145   1          
 146   1         /* 将dx、dy取绝对值 */
 147   1         dx = dx_sym * dx;
 148   1         dy = dy_sym * dy;
 149   1       
 150   1         /* 计算2倍的dx及dy值 */
 151   1         dx_x2 = dx*2;
 152   1         dy_x2 = dy*2;
 153   1         
 154   1         /* 使用Bresenham法进行画直线 */
 155   1         if(dx>=dy)           // 对于dx>=dy，则使用x轴为基准
 156   1         {  di = dy_x2 - dx;
 157   2            while(x0!=x1)
 158   2            {  GUI_Point(x0, y0, color);
 159   3               x0 += dx_sym;
 160   3               if(di<0)
 161   3               {  di += dy_x2;      // 计算出下一步的决策值
 162   4               }
 163   3               else
 164   3               {  di += dy_x2 - dx_x2;
 165   4                  y0 += dy_sym;
 166   4               }
 167   3            }
 168   2            GUI_Point(x0, y0, color);   // 显示最后一点
 169   2         }
 170   1         else               // 对于dx<dy，则使用y轴为基准
 171   1         {  di = dx_x2 - dy;
 172   2            while(y0!=y1)
 173   2            {  GUI_Point(x0, y0, color);
 174   3               y0 += dy_sym;
 175   3               if(di<0)
 176   3               {  di += dx_x2;
 177   4               }
 178   3               else
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 4   

 179   3               {  di += dx_x2 - dy_x2;
 180   4                  x0 += dx_sym;
 181   4               }
 182   3            }
 183   2            GUI_Point(x0, y0, color);   // 显示最后一点
 184   2         } 
 185   1        
 186   1      }
 187          
 188          #endif
 189          
 190          #if GUI_LineSX_EN==1
              /****************************************************************************
              * 名称：GUI_LineS()
              * 功能：多个点之间的连续连线。从第一点连到第二点，再连到第三点...
              * 入口参数： points  多个点坐标数据的指针，数据排列为(x0,y0)、(x1,y1)、(x2,y2)...
              *           no      点数目，至少要大于1
              *           color 显示颜色
              * 出口参数：无
              * 说明：操作失败原因是指定地址超出有效范围。
              ****************************************************************************/
              void  GUI_LineS(uint32 const *points, uint8 no, TCOLOR color)
              {  uint32  x0, y0;
                 uint32  x1, y1;
                 uint8  i;
              
                 /* 入口参数过滤 */
                 if(0==no) return;
                 if(1==no)            // 单点
                 {  x0 = *points++;
                    y0 = *points;
                    GUI_Point(x0, y0, color);
                 }
                 
                 /* 画多条线条 */
                 x0 = *points++;          // 取出第一点坐标值，作为原起点坐标值
                 y0 = *points++;
                 for(i=1; i<no; i++)
                 {  x1 = *points++;       // 取出下一点坐标值
                    y1 = *points++;
                    GUI_Line(x0, y0, x1, y1, color);
                    x0 = x1;            // 更新原起点坐标
                    y0 = y1;
                 }
              }
              #endif
 225          
 226          
 227          #if GUI_LineWith_EN==1
              /****************************************************************************
              * 名称：GUI_LineWith()
              * 功能：画任意两点之间的直线，并且可设置线的宽度。
              * 入口参数： x0   直线起点的x坐标值
              *           y0    直线起点的y坐标值
              *           x1      直线终点的x坐标值
              *           y1      直线终点的y坐标值
              *           with    线宽(0-50)
              *           color 显示颜色
              * 出口参数：无
              * 说明：操作失败原因是指定地址超出有效范围。
              ****************************************************************************/
              void  GUI_LineWith(uint32 x0, uint32 y0, uint32 x1, uint32 y1, uint8 with, TCOLOR color)
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 5   

              {  int32   dx;            // 直线x轴差值变量
                 int32   dy;                // 直线y轴差值变量
                 int8    dx_sym;          // x轴增长方向，为-1时减值方向，为1时增值方向
                 int8    dy_sym;          // y轴增长方向，为-1时减值方向，为1时增值方向
                 int32   dx_x2;         // dx*2值变量，用于加快运算速度
                 int32   dy_x2;         // dy*2值变量，用于加快运算速度
                 int32   di;            // 决策变量
                 
                 int32   wx, wy;          // 线宽变量
                 int32   draw_a, draw_b;
                 
                 /* 参数过滤 */
                 if(with==0) return;
                 if(with>50) with = 50;
                 
                 dx = x1-x0;            // 求取两点之间的差值
                 dy = y1-y0;
                 
                 wx = with/2;
                 wy = with-wx-1;
                 
                 /* 判断增长方向，或是否为水平线、垂直线、点 */
                 if(dx>0)             // 判断x轴方向
                 {  dx_sym = 1;         // dx>0，设置dx_sym=1
                 }
                 else
                 {  if(dx<0)
                    {  dx_sym = -1;       // dx<0，设置dx_sym=-1
                    }
                    else
                    {  /* dx==0，画垂直线，或一点 */
                       wx = x0-wx;
                       if(wx<0) wx = 0;
                       wy = x0+wy;
                       
                       while(1)
                       {  x0 = wx;
                          GUI_RLine(x0, y0, y1, color);
                          if(wx>=wy) break;
                          wx++;
                       }
                       
                       return;
                    }
                 }
                 
                 if(dy>0)             // 判断y轴方向
                 {  dy_sym = 1;         // dy>0，设置dy_sym=1
                 }
                 else
                 {  if(dy<0)
                    {  dy_sym = -1;       // dy<0，设置dy_sym=-1
                    }
                    else
                    {  /* dy==0，画水平线，或一点 */
                       wx = y0-wx;
                       if(wx<0) wx = 0;
                       wy = y0+wy;
                       
                       while(1)
                       {  y0 = wx;
                          GUI_HLine(x0, y0, x1, color);
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 6   

                          if(wx>=wy) break;
                          wx++;
                       }
                       return;
                    }
                 }
                  
                 /* 将dx、dy取绝对值 */
                 dx = dx_sym * dx;
                 dy = dy_sym * dy;
               
                 /* 计算2倍的dx及dy值 */
                 dx_x2 = dx*2;
                 dy_x2 = dy*2;
                 
                 /* 使用Bresenham法进行画直线 */
                 if(dx>=dy)           // 对于dx>=dy，则使用x轴为基准
                 {  di = dy_x2 - dx;
                    while(x0!=x1)
                    {  /* x轴向增长，则宽度在y方向，即画垂直线 */
                       draw_a = y0-wx;
                       if(draw_a<0) draw_a = 0;
                       draw_b = y0+wy;
                       GUI_RLine(x0, draw_a, draw_b, color);
                       
                       x0 += dx_sym;        
                       if(di<0)
                       {  di += dy_x2;      // 计算出下一步的决策值
                       }
                       else
                       {  di += dy_x2 - dx_x2;
                          y0 += dy_sym;
                       }
                    }
                    draw_a = y0-wx;
                    if(draw_a<0) draw_a = 0;
                    draw_b = y0+wy;
                    GUI_RLine(x0, draw_a, draw_b, color);
                 }
                 else               // 对于dx<dy，则使用y轴为基准
                 {  di = dx_x2 - dy;
                    while(y0!=y1)
                    {  /* y轴向增长，则宽度在x方向，即画水平线 */
                       draw_a = x0-wx;
                       if(draw_a<0) draw_a = 0;
                       draw_b = x0+wy;
                       GUI_HLine(draw_a, y0, draw_b, color);
                       
                       y0 += dy_sym;
                       if(di<0)
                       {  di += dx_x2;
                       }
                       else
                       {  di += dx_x2 - dy_x2;
                          x0 += dx_sym;
                       }
                    }
                    draw_a = x0-wx;
                    if(draw_a<0) draw_a = 0;
                    draw_b = x0+wy;
                    GUI_HLine(draw_a, y0, draw_b, color);
                 } 
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 7   

                
              }
              #endif
 368          
 369          
 370          
 371          #if  GUI_CircleX_EN==1
 372          /****************************************************************************
 373          * 名称：GUI_Circle()
 374          * 功能：指定圆心位置及半径，画圆。
 375          * 入口参数： x0   圆心的x坐标值
 376          *           y0    圆心的y坐标值
 377          *           r       圆的半径
 378          *           color 显示颜色
 379          * 出口参数：无
 380          * 说明：操作失败原因是指定地址超出有效范围。
 381          ****************************************************************************/
 382          void  GUI_Circle(uint32 x0, uint32 y0, uint32 r, TCOLOR color)
 383          {  int32  draw_x0, draw_y0;     // 刽图点坐标变量
 384   1         int32  draw_x1, draw_y1; 
 385   1         int32  draw_x2, draw_y2; 
 386   1         int32  draw_x3, draw_y3; 
 387   1         int32  draw_x4, draw_y4; 
 388   1         int32  draw_x5, draw_y5; 
 389   1         int32  draw_x6, draw_y6; 
 390   1         int32  draw_x7, draw_y7; 
 391   1         int32  xx, yy;         // 画圆控制变量
 392   1       
 393   1         int32  di;           // 决策变量
 394   1         
 395   1         /* 参数过滤 */
 396   1         if(0==r) return;
 397   1         
 398   1         /* 计算出8个特殊点(0、45、90、135、180、225、270度)，进行显示 */
 399   1         draw_x0 = draw_x1 = x0;
 400   1         draw_y0 = draw_y1 = y0 + r;
 401   1         if(draw_y0<GUI_LCM_YMAX) GUI_Point(draw_x0, draw_y0, color); // 90度
 402   1        
 403   1         draw_x2 = draw_x3 = x0;
 404   1         draw_y2 = draw_y3 = y0 - r;
 405   1         if(draw_y2>=0) GUI_Point(draw_x2, draw_y2, color);     // 270度
 406   1         
 407   1        
 408   1         draw_x4 = draw_x6 = x0 + r;
 409   1         draw_y4 = draw_y6 = y0;
 410   1         if(draw_x4<GUI_LCM_XMAX) GUI_Point(draw_x4, draw_y4, color); // 0度
 411   1         
 412   1         draw_x5 = draw_x7 = x0 - r;
 413   1         draw_y5 = draw_y7 = y0;
 414   1         if(draw_x5>=0) GUI_Point(draw_x5, draw_y5, color);     // 180度   
 415   1         if(1==r) return;         // 若半径为1，则已圆画完
 416   1         
 417   1         
 418   1         /* 使用Bresenham法进行画圆 */
 419   1         di = 3 - 2*r;          // 初始化决策变量
 420   1         
 421   1         xx = 0;
 422   1         yy = r;  
 423   1         while(xx<yy)
 424   1         {  if(di<0)
 425   2          {  di += 4*xx + 6;        
 426   3          }
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 8   

 427   2          else
 428   2          {  di += 4*(xx - yy) + 10;
 429   3          
 430   3             yy--;    
 431   3           draw_y0--;
 432   3           draw_y1--;
 433   3           draw_y2++;
 434   3           draw_y3++;
 435   3           draw_x4--;
 436   3           draw_x5++;
 437   3           draw_x6--;
 438   3           draw_x7++;   
 439   3          }
 440   2          
 441   2          xx++;   
 442   2          draw_x0++;
 443   2          draw_x1--;
 444   2          draw_x2++;
 445   2          draw_x3--;
 446   2          draw_y4++;
 447   2          draw_y5++;
 448   2          draw_y6--;
 449   2          draw_y7--;
 450   2          
 451   2        
 452   2          /* 要判断当前点是否在有效范围内 */
 453   2          if( (draw_x0<=GUI_LCM_XMAX)&&(draw_y0>=0) ) 
 454   2          {  GUI_Point(draw_x0, draw_y0, color);
 455   3          }     
 456   2          if( (draw_x1>=0)&&(draw_y1>=0) )  
 457   2          {  GUI_Point(draw_x1, draw_y1, color);
 458   3          }
 459   2          if( (draw_x2<=GUI_LCM_XMAX)&&(draw_y2<=GUI_LCM_YMAX) )  
 460   2          {  GUI_Point(draw_x2, draw_y2, color);   
 461   3          }
 462   2          if( (draw_x3>=0)&&(draw_y3<=GUI_LCM_YMAX) ) 
 463   2          {  GUI_Point(draw_x3, draw_y3, color);
 464   3          }
 465   2          if( (draw_x4<=GUI_LCM_XMAX)&&(draw_y4>=0) ) 
 466   2          {  GUI_Point(draw_x4, draw_y4, color);
 467   3          }
 468   2          if( (draw_x5>=0)&&(draw_y5>=0) )  
 469   2          {  GUI_Point(draw_x5, draw_y5, color);
 470   3          }
 471   2          if( (draw_x6<=GUI_LCM_XMAX)&&(draw_y6<=GUI_LCM_YMAX) )  
 472   2          {  GUI_Point(draw_x6, draw_y6, color);
 473   3          }
 474   2          if( (draw_x7>=0)&&(draw_y7<=GUI_LCM_YMAX) ) 
 475   2          {  GUI_Point(draw_x7, draw_y7, color);
 476   3          }
 477   2         }
 478   1      }
 479          
 480          
 481          /****************************************************************************
 482          * 名称：GUI_CircleFill()
 483          * 功能：指定圆心位置及半径，画圆并填充，填充色与边框色一样。
 484          * 入口参数： x0   圆心的x坐标值
 485          *           y0    圆心的y坐标值
 486          *           r       圆的半径
 487          *           color 填充颜色
 488          * 出口参数：无
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 9   

 489          * 说明：操作失败原因是指定地址超出有效范围。
 490          ****************************************************************************/
 491          void  GUI_CircleFill(uint32 x0, uint32 y0, uint32 r, TCOLOR color)
 492          {  int32  draw_x0, draw_y0;     // 刽图点坐标变量
 493   1         int32  draw_x1, draw_y1; 
 494   1         int32  draw_x2, draw_y2; 
 495   1         int32  draw_x3, draw_y3; 
 496   1         int32  draw_x4, draw_y4; 
 497   1         int32  draw_x5, draw_y5; 
 498   1         int32  draw_x6, draw_y6; 
 499   1         int32  draw_x7, draw_y7; 
 500   1         int32  fill_x0, fill_y0;     // 填充所需的变量，使用垂直线填充
 501   1         int32  fill_x1;
 502   1         int32  xx, yy;         // 画圆控制变量
 503   1       
 504   1         int32  di;           // 决策变量
 505   1         
 506   1         /* 参数过滤 */
 507   1         if(0==r) return;
 508   1         
 509   1         /* 计算出4个特殊点(0、90、180、270度)，进行显示 */
 510   1         draw_x0 = draw_x1 = x0;
 511   1         draw_y0 = draw_y1 = y0 + r;
 512   1         if(draw_y0<GUI_LCM_YMAX)
 513   1         {  GUI_Point(draw_x0, draw_y0, color); // 90度
 514   2         }
 515   1            
 516   1         draw_x2 = draw_x3 = x0;
 517   1         draw_y2 = draw_y3 = y0 - r;
 518   1         if(draw_y2>=0)
 519   1         {  GUI_Point(draw_x2, draw_y2, color); // 270度
 520   2         }
 521   1          
 522   1         draw_x4 = draw_x6 = x0 + r;
 523   1         draw_y4 = draw_y6 = y0;
 524   1         if(draw_x4<GUI_LCM_XMAX) 
 525   1         {  GUI_Point(draw_x4, draw_y4, color); // 0度
 526   2            fill_x1 = draw_x4;
 527   2         }
 528   1         else
 529   1         {  fill_x1 = GUI_LCM_XMAX;
 530   2         }
 531   1         fill_y0 = y0;              // 设置填充线条起始点fill_x0
 532   1         fill_x0 = x0 - r;            // 设置填充线条结束点fill_y1
 533   1         if(fill_x0<0) fill_x0 = 0;
 534   1         GUI_HLine(fill_x0, fill_y0, fill_x1, color);
 535   1         
 536   1         draw_x5 = draw_x7 = x0 - r;
 537   1         draw_y5 = draw_y7 = y0;
 538   1         if(draw_x5>=0) 
 539   1         {  GUI_Point(draw_x5, draw_y5, color); // 180度
 540   2         }
 541   1         if(1==r) return;
 542   1         
 543   1         
 544   1         /* 使用Bresenham法进行画圆 */
 545   1         di = 3 - 2*r;              // 初始化决策变量
 546   1         
 547   1         xx = 0;
 548   1         yy = r;
 549   1         while(xx<yy)
 550   1         {  if(di<0)
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 10  

 551   2          {  di += 4*xx + 6;
 552   3          }
 553   2          else
 554   2          {  di += 4*(xx - yy) + 10;
 555   3          
 556   3             yy--;    
 557   3           draw_y0--;
 558   3           draw_y1--;
 559   3           draw_y2++;
 560   3           draw_y3++;
 561   3           draw_x4--;
 562   3           draw_x5++;
 563   3           draw_x6--;
 564   3           draw_x7++;    
 565   3          }
 566   2          
 567   2          xx++;   
 568   2          draw_x0++;
 569   2          draw_x1--;
 570   2          draw_x2++;
 571   2          draw_x3--;
 572   2          draw_y4++;
 573   2          draw_y5++;
 574   2          draw_y6--;
 575   2          draw_y7--;
 576   2          
 577   2        
 578   2          /* 要判断当前点是否在有效范围内 */
 579   2          if( (draw_x0<=GUI_LCM_XMAX)&&(draw_y0>=0) ) 
 580   2          {  GUI_Point(draw_x0, draw_y0, color);
 581   3          }     
 582   2          if( (draw_x1>=0)&&(draw_y1>=0) )  
 583   2          {  GUI_Point(draw_x1, draw_y1, color);
 584   3          }
 585   2          
 586   2          /* 第二点水直线填充(下半圆的点) */
 587   2          if(draw_x1>=0)
 588   2          {  /* 设置填充线条起始点fill_x0 */
 589   3             fill_x0 = draw_x1;
 590   3             /* 设置填充线条起始点fill_y0 */
 591   3             fill_y0 = draw_y1;
 592   3               if(fill_y0>GUI_LCM_YMAX) fill_y0 = GUI_LCM_YMAX;
 593   3               if(fill_y0<0) fill_y0 = 0; 
 594   3               /* 设置填充线条结束点fill_x1 */                  
 595   3               fill_x1 = x0*2 - draw_x1;        
 596   3               if(fill_x1>GUI_LCM_XMAX) fill_x1 = GUI_LCM_XMAX;
 597   3               GUI_HLine(fill_x0, fill_y0, fill_x1, color);
 598   3            }
 599   2          
 600   2          
 601   2          if( (draw_x2<=GUI_LCM_XMAX)&&(draw_y2<=GUI_LCM_YMAX) )  
 602   2          {  GUI_Point(draw_x2, draw_y2, color);   
 603   3          }
 604   2                
 605   2          if( (draw_x3>=0)&&(draw_y3<=GUI_LCM_YMAX) ) 
 606   2          {  GUI_Point(draw_x3, draw_y3, color);
 607   3          }
 608   2          
 609   2          /* 第四点垂直线填充(上半圆的点) */
 610   2          if(draw_x3>=0)
 611   2          {  /* 设置填充线条起始点fill_x0 */
 612   3             fill_x0 = draw_x3;
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 11  

 613   3             /* 设置填充线条起始点fill_y0 */
 614   3             fill_y0 = draw_y3;
 615   3               if(fill_y0>GUI_LCM_YMAX) fill_y0 = GUI_LCM_YMAX;
 616   3               if(fill_y0<0) fill_y0 = 0;
 617   3               /* 设置填充线条结束点fill_x1 */                  
 618   3               fill_x1 = x0*2 - draw_x3;        
 619   3               if(fill_x1>GUI_LCM_XMAX) fill_x1 = GUI_LCM_XMAX;
 620   3               GUI_HLine(fill_x0, fill_y0, fill_x1, color);
 621   3            }
 622   2          
 623   2              
 624   2          if( (draw_x4<=GUI_LCM_XMAX)&&(draw_y4>=0) ) 
 625   2          {  GUI_Point(draw_x4, draw_y4, color);
 626   3          }
 627   2          if( (draw_x5>=0)&&(draw_y5>=0) )  
 628   2          {  GUI_Point(draw_x5, draw_y5, color);
 629   3          }
 630   2          
 631   2          /* 第六点垂直线填充(上半圆的点) */
 632   2          if(draw_x5>=0)
 633   2          {  /* 设置填充线条起始点fill_x0 */
 634   3             fill_x0 = draw_x5;
 635   3             /* 设置填充线条起始点fill_y0 */
 636   3             fill_y0 = draw_y5;
 637   3               if(fill_y0>GUI_LCM_YMAX) fill_y0 = GUI_LCM_YMAX;
 638   3               if(fill_y0<0) fill_y0 = 0;
 639   3               /* 设置填充线条结束点fill_x1 */                  
 640   3               fill_x1 = x0*2 - draw_x5;        
 641   3               if(fill_x1>GUI_LCM_XMAX) fill_x1 = GUI_LCM_XMAX;
 642   3               GUI_HLine(fill_x0, fill_y0, fill_x1, color);
 643   3            }
 644   2          
 645   2          
 646   2          if( (draw_x6<=GUI_LCM_XMAX)&&(draw_y6<=GUI_LCM_YMAX) )  
 647   2          {  GUI_Point(draw_x6, draw_y6, color);
 648   3          }
 649   2          
 650   2          if( (draw_x7>=0)&&(draw_y7<=GUI_LCM_YMAX) ) 
 651   2          {  GUI_Point(draw_x7, draw_y7, color);
 652   3          }
 653   2          
 654   2          /* 第八点垂直线填充(上半圆的点) */
 655   2          if(draw_x7>=0)
 656   2          {  /* 设置填充线条起始点fill_x0 */
 657   3             fill_x0 = draw_x7;
 658   3             /* 设置填充线条起始点fill_y0 */
 659   3             fill_y0 = draw_y7;
 660   3               if(fill_y0>GUI_LCM_YMAX) fill_y0 = GUI_LCM_YMAX;
 661   3               if(fill_y0<0) fill_y0 = 0;
 662   3               /* 设置填充线条结束点fill_x1 */                  
 663   3               fill_x1 = x0*2 - draw_x7;        
 664   3               if(fill_x1>GUI_LCM_XMAX) fill_x1 = GUI_LCM_XMAX;
 665   3               GUI_HLine(fill_x0, fill_y0, fill_x1, color);
 666   3            }
 667   2          
 668   2         }
 669   1      }
 670          #endif
 671          
 672          
 673          
 674          
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 12  

 675          #if  GUI_EllipseX_EN==1
 676          /****************************************************************************
 677          * 名称：GUI_Ellipse()
 678          * 功能：画正椭圆。给定椭圆的四个点的参数，最左、最右点的x轴坐标值为x0、x1，最上、最下点
 679          *      的y轴坐标为y0、y1。
 680          * 入口参数： x0   最左点的x坐标值
 681          *           x1    最右点的x坐标值
 682          *           y0    最上点的y坐标值
 683          *           y1      最下点的y坐标值
 684          *           color 显示颜色
 685          * 出口参数：无
 686          * 说明：操作失败原因是指定地址超出有效范围。
 687          ****************************************************************************/
 688          void  GUI_Ellipse(uint32 x0, uint32 x1, uint32 y0, uint32 y1, TCOLOR color)
 689          {  int32  draw_x0, draw_y0;     // 刽图点坐标变量
 690   1         int32  draw_x1, draw_y1;
 691   1         int32  draw_x2, draw_y2;
 692   1         int32  draw_x3, draw_y3;
 693   1         int32  xx, yy;         // 画图控制变量
 694   1          
 695   1         int32  center_x, center_y;   // 椭圆中心点坐标变量
 696   1         int32  radius_x, radius_y;   // 椭圆的半径，x轴半径和y轴半径
 697   1         int32  radius_xx, radius_yy;   // 半径乘平方值
 698   1         int32  radius_xx2, radius_yy2; // 半径乘平方值的两倍
 699   1         int32  di;           // 定义决策变量
 700   1        
 701   1         /* 参数过滤 */
 702   1         if( (x0==x1) || (y0==y1) ) return;
 703   1          
 704   1         /* 计算出椭圆中心点坐标 */
 705   1         center_x = (x0 + x1) >> 1;     
 706   1         center_y = (y0 + y1) >> 1;
 707   1         
 708   1         /* 计算出椭圆的半径，x轴半径和y轴半径 */
 709   1         if(x0 > x1)
 710   1         {  radius_x = (x0 - x1) >> 1;
 711   2         }
 712   1         else
 713   1         {  radius_x = (x1 - x0) >> 1;
 714   2         }
 715   1         if(y0 > y1)
 716   1         {  radius_y = (y0 - y1) >> 1;
 717   2         }
 718   1         else
 719   1         {  radius_y = (y1 - y0) >> 1;
 720   2         }
 721   1          
 722   1         /* 计算半径平方值 */
 723   1         radius_xx = radius_x * radius_x;
 724   1         radius_yy = radius_y * radius_y;
 725   1        
 726   1         /* 计算半径平方值乘2值 */
 727   1         radius_xx2 = radius_xx<<1;
 728   1         radius_yy2 = radius_yy<<1;
 729   1        
 730   1         /* 初始化画图变量 */
 731   1         xx = 0;
 732   1         yy = radius_y;
 733   1        
 734   1         di = radius_yy2 + radius_xx - radius_xx2*radius_y ;  // 初始化决策变量 
 735   1        
 736   1         /* 计算出椭圆y轴上的两个端点坐标，作为作图起点 */
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 13  

 737   1         draw_x0 = draw_x1 = draw_x2 = draw_x3 = center_x;
 738   1         draw_y0 = draw_y1 = center_y + radius_y;
 739   1         draw_y2 = draw_y3 = center_y - radius_y;
 740   1        
 741   1         
 742   1         GUI_Point(draw_x0, draw_y0, color);          // 画y轴上的两个端点 
 743   1         GUI_Point(draw_x2, draw_y2, color);
 744   1        
 745   1         while( (radius_yy*xx) < (radius_xx*yy) ) 
 746   1         {  if(di<0)
 747   2          {  di+= radius_yy2*(2*xx+3);
 748   3          }
 749   2          else
 750   2          {  di += radius_yy2*(2*xx+3) + 4*radius_xx - 4*radius_xx*yy;
 751   3            
 752   3             yy--;
 753   3           draw_y0--;
 754   3           draw_y1--;
 755   3           draw_y2++;
 756   3           draw_y3++;        
 757   3          }
 758   2          
 759   2          xx ++;            // x轴加1
 760   2            
 761   2          draw_x0++;
 762   2          draw_x1--;
 763   2          draw_x2++;
 764   2          draw_x3--;
 765   2          
 766   2          GUI_Point(draw_x0, draw_y0, color);
 767   2          GUI_Point(draw_x1, draw_y1, color);
 768   2          GUI_Point(draw_x2, draw_y2, color);
 769   2          GUI_Point(draw_x3, draw_y3, color);
 770   2         }
 771   1        
 772   1         di = radius_xx2*(yy-1)*(yy-1) + radius_yy2*xx*xx + radius_yy + radius_yy2*xx - radius_xx2*radius_yy;
 773   1         while(yy>=0) 
 774   1         {  if(di<0)
 775   2          {  di+= radius_xx2*3 + 4*radius_yy*xx + 4*radius_yy - 2*radius_xx2*yy;
 776   3            
 777   3             xx ++;           // x轴加1     
 778   3             draw_x0++;
 779   3             draw_x1--;
 780   3             draw_x2++;
 781   3             draw_x3--;  
 782   3          }
 783   2          else
 784   2          {  di += radius_xx2*3 - 2*radius_xx2*yy;                   
 785   3          }
 786   2          
 787   2          yy--;
 788   2          draw_y0--;
 789   2          draw_y1--;
 790   2          draw_y2++;
 791   2          draw_y3++;  
 792   2          
 793   2          GUI_Point(draw_x0, draw_y0, color);
 794   2          GUI_Point(draw_x1, draw_y1, color);
 795   2          GUI_Point(draw_x2, draw_y2, color);
 796   2          GUI_Point(draw_x3, draw_y3, color);
 797   2         }     
 798   1      }
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 14  

 799          
 800          
 801          /****************************************************************************
 802          * 名称：GUI_EllipseFill()
 803          * 功能：画正椭圆，并填充。给定椭圆的四个点的参数，最左、最右点的x轴坐标值为x0、x1，最上、最下点
 804          *      的y轴坐标为y0、y1。
 805          * 入口参数： x0   最左点的x坐标值
 806          *           x1    最右点的x坐标值
 807          *           y0    最上点的y坐标值
 808          *           y1      最下点的y坐标值
 809          *           color 填充颜色
 810          * 出口参数：无
 811          * 说明：操作失败原因是指定地址超出有效范围。
 812          ****************************************************************************/
 813          void  GUI_EllipseFill(uint32 x0, uint32 x1, uint32 y0, uint32 y1, TCOLOR color)
 814          {  int32  draw_x0, draw_y0;     // 刽图点坐标变量
 815   1         int32  draw_x1, draw_y1;
 816   1         int32  draw_x2, draw_y2;
 817   1         int32  draw_x3, draw_y3;
 818   1         int32  xx, yy;         // 画图控制变量
 819   1          
 820   1         int32  center_x, center_y;   // 椭圆中心点坐标变量
 821   1         int32  radius_x, radius_y;   // 椭圆的半径，x轴半径和y轴半径
 822   1         int32  radius_xx, radius_yy;   // 半径乘平方值
 823   1         int32  radius_xx2, radius_yy2; // 半径乘平方值的两倍
 824   1         int32  di;           // 定义决策变量
 825   1        
 826   1         /* 参数过滤 */
 827   1         if( (x0==x1) || (y0==y1) ) return;
 828   1         
 829   1         /* 计算出椭圆中心点坐标 */
 830   1         center_x = (x0 + x1) >> 1;     
 831   1         center_y = (y0 + y1) >> 1;
 832   1         
 833   1         /* 计算出椭圆的半径，x轴半径和y轴半径 */
 834   1         if(x0 > x1)
 835   1         {  radius_x = (x0 - x1) >> 1;
 836   2         }
 837   1         else
 838   1         {  radius_x = (x1 - x0) >> 1;
 839   2         }
 840   1         if(y0 > y1)
 841   1         {  radius_y = (y0 - y1) >> 1;
 842   2         }
 843   1         else
 844   1         {  radius_y = (y1 - y0) >> 1;
 845   2         }
 846   1          
 847   1         /* 计算半径乘平方值 */
 848   1         radius_xx = radius_x * radius_x;
 849   1         radius_yy = radius_y * radius_y;
 850   1        
 851   1         /* 计算半径乘4值 */
 852   1         radius_xx2 = radius_xx<<1;
 853   1         radius_yy2 = radius_yy<<1;
 854   1         
 855   1          /* 初始化画图变量 */
 856   1         xx = 0;
 857   1         yy = radius_y;
 858   1        
 859   1         di = radius_yy2 + radius_xx - radius_xx2*radius_y ;  // 初始化决策变量 
 860   1        
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 15  

 861   1         /* 计算出椭圆y轴上的两个端点坐标，作为作图起点 */
 862   1         draw_x0 = draw_x1 = draw_x2 = draw_x3 = center_x;
 863   1         draw_y0 = draw_y1 = center_y + radius_y;
 864   1         draw_y2 = draw_y3 = center_y - radius_y;
 865   1        
 866   1         
 867   1         GUI_Point(draw_x0, draw_y0, color);          // 画y轴上的两个端点
 868   1         GUI_Point(draw_x2, draw_y2, color);
 869   1        
 870   1         while( (radius_yy*xx) < (radius_xx*yy) ) 
 871   1         {  if(di<0)
 872   2          {  di+= radius_yy2*(2*xx+3);
 873   3          }
 874   2          else
 875   2          {  di += radius_yy2*(2*xx+3) + 4*radius_xx - 4*radius_xx*yy;
 876   3            
 877   3             yy--;
 878   3           draw_y0--;
 879   3           draw_y1--;
 880   3           draw_y2++;
 881   3           draw_y3++;        
 882   3          }
 883   2          
 884   2          xx ++;            // x轴加1
 885   2            
 886   2          draw_x0++;
 887   2          draw_x1--;
 888   2          draw_x2++;
 889   2          draw_x3--;
 890   2          
 891   2          GUI_Point(draw_x0, draw_y0, color);
 892   2          GUI_Point(draw_x1, draw_y1, color);
 893   2          GUI_Point(draw_x2, draw_y2, color);
 894   2          GUI_Point(draw_x3, draw_y3, color);
 895   2          
 896   2          /* 若y轴已变化，进行填充 */
 897   2          if(di>=0)
 898   2          {  GUI_HLine(draw_x0, draw_y0, draw_x1, color);
 899   3             GUI_HLine(draw_x2, draw_y2, draw_x3, color);
 900   3          }
 901   2         }
 902   1        
 903   1         di = radius_xx2*(yy-1)*(yy-1) + radius_yy2*xx*xx + radius_yy + radius_yy2*xx - radius_xx2*radius_yy;
 904   1         while(yy>=0) 
 905   1         {  if(di<0)
 906   2          {  di+= radius_xx2*3 + 4*radius_yy*xx + 4*radius_yy - 2*radius_xx2*yy;
 907   3            
 908   3             xx ++;           // x轴加1     
 909   3             draw_x0++;
 910   3             draw_x1--;
 911   3             draw_x2++;
 912   3             draw_x3--;  
 913   3          }
 914   2          else
 915   2          {  di += radius_xx2*3 - 2*radius_xx2*yy;                   
 916   3          }
 917   2          
 918   2          yy--;
 919   2          draw_y0--;
 920   2          draw_y1--;
 921   2          draw_y2++;
 922   2          draw_y3++;  
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 16  

 923   2          
 924   2          GUI_Point(draw_x0, draw_y0, color);
 925   2          GUI_Point(draw_x1, draw_y1, color);
 926   2          GUI_Point(draw_x2, draw_y2, color);
 927   2          GUI_Point(draw_x3, draw_y3, color);
 928   2          
 929   2          /* y轴已变化，进行填充 */
 930   2          GUI_HLine(draw_x0, draw_y0, draw_x1, color);
 931   2          GUI_HLine(draw_x2, draw_y2, draw_x3, color); 
 932   2         }     
 933   1      }
 934          #endif
 935          
 936          
 937          
 938          
 939          #if  GUI_FloodFill_EN==1
              /****************************************************************************
              * 名称：GUI_ReadLeftPoint()
              * 功能：找出指定点左边最近的非color点。
              * 入口参数： x0   指定点的x坐标值
              *           y0    指定点的y坐标值
              *           color 指定颜色值
              * 出口参数：返回该点的x轴坐标值。
              * 说明：若没有找出，则返回最左的x坐标0。
              ****************************************************************************/
              uint32  GUI_ReadLeftPoint(uint32 x0, uint32 y0, TCOLOR color)
              {  uint32  i;
                 TCOLOR  bakc;
                 
                 for(i=x0-1; i>0; i--)
                 {  GUI_ReadPoint(i, y0, &bakc);
                    if( GUI_CmpColor(bakc,color)==0 ) return(i+1);  // 若找到，则返回
                 }
                 GUI_ReadPoint(i, y0, &bakc);
                 if( GUI_CmpColor(bakc,color)==0 ) return(1);   // 若找到，则返回
                 
                 return(0);
              }
              
              
              /****************************************************************************
              * 名称：GUI_ReadRightPoint()
              * 功能：找出指定点右边最近的非color点。
              * 入口参数： x0   指定点的x轴坐标值
              *           y0    指定点的y轴坐标值
              *           color 指定颜色值
              * 出口参数：返回该点的x轴坐标值。
              * 说明：若没有找出，则返回最右的x坐标GUI_LCM_XMAX。
              ****************************************************************************/
              uint32  GUI_ReadRightPoint(uint32 x0, uint32 y0, TCOLOR color)
              {  uint32  i;
                 TCOLOR  bakc;
                 
                 for(i=x0+1; i<GUI_LCM_XMAX; i++)
                 {  GUI_ReadPoint(i, y0, &bakc);
                    if( GUI_CmpColor(bakc,color)==0 ) return(i-1);  // 若找到，则返回
                 }
                 return(GUI_LCM_XMAX);
              }
              
              
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 17  

              /****************************************************************************
              * 名称：GUI_CmpPointColor()
              * 功能：判断指定点上的颜色是否为某种颜色。
              * 入口参数：x     指定点的x轴坐标值
              *      y    指定点的y轴坐标值
              *          color  颜色值
              * 出口参数：返回1表示相同，返回0表示不相同。
              * 说明：
              ****************************************************************************/
              int  GUI_CmpPointColor(uint32 x, uint32 y, TCOLOR color)
              {  TCOLOR  bakc;
                 
                 GUI_ReadPoint(x, y, &bakc);
                 return( GUI_CmpColor(bakc,color) );  
              }
              
              
              /* 定义折点个数 */
              #ifndef  DOWNP_N
              #define  DOWNP_N    20
              #endif
              #ifndef  UPP_N
              #define  UPP_N      20
              #endif
              /****************************************************************************
              * 名称：GUI_FloodFill()
              * 功能：图形填充，将指定点内的封闭图形进行填充。对指定点的颜色区域进行填充，即不是该颜色
              *      的像素为边界(如，指定点上的颜色为红色，则其它颜色像素均为边界)。
              * 入口参数： x0   指定点的x坐标值
              *           y0    指定点的y坐标值
              *           color 填充颜色
              * 出口参数：无
              * 说明：操作失败原因是指定地址超出有效范围、指定点不在封闭图形内。
              ****************************************************************************/
              void  GUI_FloodFill(uint32 x0, uint32 y0, TCOLOR color)
              {  PointXY  down_point[DOWNP_N];  // 定义向下填充转折点缓冲区
                 uint8    down_no;        // 向下折点个数
                 PointXY  up_point[UPP_N];    // 定义向上填充转折点缓冲区
                 uint8    up_no;          // 向上折点个数
                 TCOLOR   fcolor;         // 填充点上的颜色
                 
                 uint32  xx, yy;          // 填充临时x，y变量 (当前填充行的中点)
                 uint32  xx0;           // 当前填充行的左x值变量
                 uint32  xx1;           // 当前填充行的右y值变量
                 uint32  i;
                 
                 uint32  x0_bak, y0_bak;
                 uint32  x1_bak;
                 
                 /* 参数过滤 */
                 if(x0>=GUI_LCM_XMAX) return;
                 if(y0>=GUI_LCM_YMAX) return;
                 
                 /* 判断指定点是否为填充颜色，若是则直接返回 */
                 GUI_ReadPoint(x0, y0, &fcolor);            // 取得填充点的颜色
                 if( GUI_CmpColor(fcolor,color)!=0 ) return;
                 
                 y0_bak = y0;
                 x0_bak = xx0 = GUI_ReadLeftPoint(x0, y0, fcolor);        // 找出当前y坐标上的最左边的点
                 x1_bak = xx1 = GUI_ReadRightPoint(x0, y0, fcolor);     // 找出当前y坐标上的最右边的点
                 down_point[0].x = up_point[0].x = (xx1 + xx0)/2;
                 down_point[0].y = up_point[0].y = y0;
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 18  

                 down_no = 1;
                 up_no = 1;
                          
                 /* 开始向上填充 */
              FILL_UP:  
                 if(0==up_no) goto FILL_DOWN;             // 若向下扫描已完成，则退出
                 xx = up_point[up_no-1].x;              // 否则取出下一折点
                 yy = up_point[up_no-1].y;
                 up_no--; 
                 xx0 = GUI_ReadLeftPoint(xx, yy, fcolor);
                 xx1 = GUI_ReadRightPoint(xx, yy, fcolor);
                 while(1) 
                 {  yy += 1;                      // 中心点向上一点
                     
                    if( GUI_CmpPointColor(xx, yy, fcolor)==0 )          
                    {  /* 判断此点是否为终点，若是则退出此次循环 */
                       for(i=xx0; i<=xx1; i++)              // 查找此行是否有需填充点
                       {  if( GUI_CmpPointColor(i, yy, fcolor)!=0 ) break;
                       }
                       if(i>xx1) goto FILL_UP; 
                       
                       /* 找出新一行中最右边的点 */
                       xx = i;                    // 更新xx到要填充的有效区域内
                       xx1 = GUI_ReadRightPoint(xx, yy, fcolor);
                    }
                    else
                    {  /* 找出新一行中最右边的点 */
                       xx1 = GUI_ReadRightPoint(xx, yy, fcolor);
                    }
                    xx0 = GUI_ReadLeftPoint(xx, yy, fcolor);
                    
                    /* 向下折点。使用y0作为折点变量，x0作为上一折点变量 */
                    if(down_no<DOWNP_N)
                    {  y0 = xx0;
                       x0 = y0-1;
                       for(i=y0; i<=xx1; i++)
                       {  if( GUI_CmpPointColor(i, yy-1, fcolor)==0 ) // 更新折点
                          {  y0 = i;                    
                          }
                          else
                          {  if(x0!=y0)               // 找到新的折点
                             {  x0 = y0;
                                down_point[down_no].x = i;
                                down_point[down_no].y = yy;
                                down_no++;
                             }
                          }
                          if(down_no>=DOWNP_N) break;         // 若缓冲区已保存满，则退出
                       } // end  of for(i=y0+1; i<xx1; i++)
                    } // end of if(down_no<DOWNP_N)
                    
                    xx = (xx1 + xx0)/2;               // 更新中心点
                    GUI_HLine(xx0, yy, xx1, color);         // 填充一行
                    
                    /* 向上折点。使用y0作为折点变量，x0作为上一折点变量 */
                    if(up_no<UPP_N)
                    {  y0 = xx0;
                       x0 = y0-1;
                       for(i=y0; i<=xx1; i++)
                       {  if( GUI_CmpPointColor(i, yy+1, fcolor)==0 ) // 更新折点
                          {  y0 = i;                    
                          }
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 19  

                          else
                          {  if(x0!=y0)               // 找到新的折点
                             {  x0 = y0;
                                up_point[up_no].x = i;
                                up_point[up_no].y = yy;
                                up_no++;
                             }
                          }
                          if(up_no>=UPP_N) break;           // 若缓冲区已保存满，则退出
                       }
                    } // end of if(up_no<UPP_N)
                    
                 } // end of while(1) 
              
                 /* 向下填充 */
              FILL_DOWN: 
                 if(0==down_no) 
                 {  if(0==up_no) 
                    {  GUI_HLine(x0_bak, y0_bak, x1_bak, color);
                       return;                // 若向下扫描已完成，且没有发现新的向上折点，则退出
                    }
                    else
                    {  goto FILL_UP;
                    }
                 }
                 xx = down_point[down_no-1].x;            // 否则取出下一折点
                 yy = down_point[down_no-1].y;
                 down_no--;
                 xx0 = GUI_ReadLeftPoint(xx, yy, fcolor);
                 xx1 = GUI_ReadRightPoint(xx, yy, fcolor);
                 
                 while(1) 
                 {  yy -= 1;                      // 中心点向上一点 
                    if( GUI_CmpPointColor(xx, yy, fcolor)==0 )          
                    {  /* 判断此点是否为终点，若是则退出此次循环 */
                       for(i=xx0; i<=xx1; i++)              // 查找下一行是否有需填充点
                       {  if( GUI_CmpPointColor(i, yy, fcolor)!=0 ) break;
                       }
                       if(i>xx1) goto FILL_DOWN; 
                       
                       /* 找出新一行中最右边的点 */
                       xx = i;
                       xx1 = GUI_ReadRightPoint(xx, yy, fcolor);
                    }
                    else
                    {  /* 找出新一行中最右边的点 */
                       xx1 = GUI_ReadRightPoint(xx, yy, fcolor);
                    }
                    xx0 = GUI_ReadLeftPoint(xx, yy, fcolor);
                          
                    /* 向上折点。使用y0作为折点变量，x0作为上一折点变量 */
                    if(up_no<UPP_N)
                    {  y0 = xx0;
                       x0 = y0-1;
                       for(i=y0; i<=xx1; i++)
                       {  if( GUI_CmpPointColor(i, yy+1, fcolor)==0 ) // 更新折点
                          {  y0 = i;                    
                          }
                          else
                          {  if(x0!=y0)               // 找到新的折点
                             {  x0 = y0;
                                up_point[up_no].x = i;
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 20  

                                up_point[up_no].y = yy;
                                up_no++;
                             }
                          }
                          if(up_no>=UPP_N) break;           // 若缓冲区已保存满，则退出
                       }
                    }
                          
                    xx = (xx1 + xx0)/2; 
                    GUI_HLine(xx0, yy, xx1, color);         // 填充一行
                    
                    /* 向下折点。使用y0作为折点变量，x0作为上一折点变量 */
                    if(down_no<DOWNP_N)
                    {  y0 = xx0;
                       x0 = y0-1;
                       for(i=y0; i<=xx1; i++)
                       {  if( GUI_CmpPointColor(i, yy-1, fcolor)==0 ) // 更新折点
                          {  y0 = i;                    
                          }
                          else
                          {  if(x0!=y0)               // 找到新的折点
                             {  x0 = y0;
                                down_point[down_no].x = i;
                                down_point[down_no].y = yy;
                                down_no++;
                             }
                          }
                          if(down_no>=DOWNP_N) break;         // 若缓冲区已保存满，则退出
                       }
                    } // end of if(down_no<DOWNP_N)
                    
                 } // end of while(1) 
                 
                 GUI_HLine(x0_bak, y0_bak, x1_bak, color);
              }
              #endif
1207          
1208          
1209          
1210          
1211          #if  GUI_ArcX_EN==1
              /****************************************************************************
              * 名称：GUI_Arc4()
              * 功能：画弧。起点及终点只能为0度-90度、90度-180度、180度-270度、270度-0度等。即分别
              *      为第1-4像限的90度弧。
              * 入口参数： x0   圆心的x坐标值
              *           y0    圆心的y坐标值
              *           r       圆弧的半径
              *           angle 画弧的像限(1-4)
              *           color 显示颜色
              * 出口参数：无
              * 说明：操作失败原因是指定地址超出有效范围。
              ****************************************************************************/
              void  GUI_Arc4(uint32 x, uint32 y, uint32 r, uint8 angle, TCOLOR color)
              {  int32  draw_x, draw_y;
              
                 int32  op_x, op_y;
                 int32  op_2rr;
                 
                 if(r==0) return;
                 
                 op_2rr = 2*r*r;                    // 计算r平方乖以2
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 21  

                 
                 switch(angle)
                 {  case  1:
                          draw_x = x+r;
                          draw_y = y;
                          
                          op_x = r;
                          op_y = 0;
               
                          while(1)
                          {  GUI_Point(draw_x, draw_y, color);    // 开始画图
                               
                             /* 计算下一点 */
                             op_y++;
                             draw_y++;
                             if( (2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0 )   // 使用逐点比较法实现画圆弧
                             {  op_x--;
                                draw_x--;
                             }
                             if(op_y>=op_x) break;
                          }
                          while(1)
                          {  GUI_Point(draw_x, draw_y, color);    // 开始画图
                               
                             /* 计算下一点 */
                             op_x--;
                             draw_x--;
                             if( (2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0 )  // 使用逐点比较法实现画圆弧
                             {  op_y++;
                                draw_y++;
                             }
                             if(op_x<=0)
                             {  GUI_Point(draw_x, draw_y, color);   // 开始画图
                                break;
                             }
                          }
                 
                          break;      
                        
                    case  2:
                          draw_x = x-r;
                          draw_y = y;
                          
                          op_x = r;
                          op_y = 0;
               
                          while(1)
                          {  GUI_Point(draw_x, draw_y, color);    // 开始画图
                               
                             /* 计算下一点 */
                             op_y++;
                             draw_y++;
                             if( (2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0 )   // 使用逐点比较法实现画圆弧
                             {  op_x--;
                                draw_x++;
                             }
                             if(op_y>=op_x) break;
                          }
                          while(1)
                          {  GUI_Point(draw_x, draw_y, color);    // 开始画图
                               
                             /* 计算下一点 */
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 22  

                             op_x--;
                             draw_x++;
                             if( (2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0 )  // 使用逐点比较法实现画圆弧
                             {  op_y++;
                                draw_y++;
                             }
                             if(op_x<=0)
                             {  GUI_Point(draw_x, draw_y, color);   // 开始画图
                                break;
                             }
                          }
                
                          break;
                          
                    case  3:
                          draw_x = x-r;
                          draw_y = y;
                          
                          op_x = r;
                          op_y = 0;
               
                          while(1)
                          {  GUI_Point(draw_x, draw_y, color);    // 开始画图
                               
                             /* 计算下一点 */
                             op_y++;
                             draw_y--;
                             if( (2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0 )   // 使用逐点比较法实现画圆弧
                             {  op_x--;
                                draw_x++;
                             }
                             if(op_y>=op_x) break;
                          }
                          while(1)
                          {  GUI_Point(draw_x, draw_y, color);    // 开始画图
                               
                             /* 计算下一点 */
                             op_x--;
                             draw_x++;
                             if( (2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0 )  // 使用逐点比较法实现画圆弧
                             {  op_y++;
                                draw_y--;
                             }
                             if(op_x<=0)
                             {  GUI_Point(draw_x, draw_y, color);   // 开始画图
                                break;
                             }
                          }
                    
                          break;
                          
                    case  4:
                          draw_x = x+r;
                          draw_y = y;
                          
                          op_x = r;
                          op_y = 0;
               
                          while(1)
                          {  GUI_Point(draw_x, draw_y, color);    // 开始画图
                               
                             /* 计算下一点 */
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 23  

                             op_y++;
                             draw_y--;
                             if( (2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0 )   // 使用逐点比较法实现画圆弧
                             {  op_x--;
                                draw_x--;
                             }
                             if(op_y>=op_x) break;
                          }
                          while(1)
                          {  GUI_Point(draw_x, draw_y, color);    // 开始画图
                               
                             /* 计算下一点 */
                             op_x--;
                             draw_x--;
                             if( (2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0 )  // 使用逐点比较法实现画圆弧
                             {  op_y++;
                                draw_y--;
                             }
                             if(op_x<=0)
                             {  GUI_Point(draw_x, draw_y, color);   // 开始画图
                                break;
                             }
                          }
                          break;
                          
                    default:
                          break;
                    
                 }
              
              }
              
              /****************************************************************************
              * 名称：GUI_Arc()
              * 功能：指定起点、终点及半径画弧(不能画圆)。使用的是顺时针方向画图。
              * 入口参数： x      圆心的x轴坐标值
              *           y     圆心的y轴坐标值
              *           stangle   起始角度(0-359度)
              *           endangle  终止角度(0-359度)
              *           r       圆的半径终点
              *           color   显示颜色
              * 出口参数：无
              * 说明：操作失败原因是指定地址超出有效范围。
              ****************************************************************************/
              void  GUI_Arc(uint32 x, uint32 y, uint32 r, uint32 stangle, uint32 endangle, TCOLOR color)
              {  int32  draw_x, draw_y;         // 画图坐标变量
                 int32  op_x, op_y;           // 操作坐标
                 int32  op_2rr;             // 2*r*r值变量
                 
                 int32  pno_angle;            // 度角点的个数
                 uint8  draw_on;              // 画点开关，为1时画点，为0时不画
                 
                 
                 /* 参数过滤 */
                 if(r==0) return;             // 半径为0则直接退出
                 if(stangle==endangle) return;      // 起始角度与终止角度相同，退出
                 if( (stangle>=360) || (endangle>=360) ) return;
              
                 op_2rr = 2*r*r;              // 计算r平方乖以2
                 pno_angle = 0;
                 /* 先计算出在此半径下的45度的圆弧的点数 */       
                 op_x = r;
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 24  

                 op_y = 0;
                 while(1)
                 {  pno_angle++;              // 画点计数         
                    /* 计算下一点 */
                    op_y++;
                    if( (2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0 )  // 使用逐点比较法实现画圆弧
                    {  op_x--;
                    }
                    if(op_y>=op_x) break;
                 }
                 
                 draw_on = 0;               // 最开始关画点开关
                 /* 设置起始点及终点 */
                 if(endangle>stangle) draw_on = 1;    // 若终点大于起点，则从一开始即画点(359)
                 stangle = (360-stangle)*pno_angle/45;
                 endangle = (360-endangle)*pno_angle/45;
                 if(stangle==0) stangle=1;
                 if(endangle==0) endangle=1;
                 
                 /* 开始顺时针画弧，从359度开始(第4像限) */
                 pno_angle = 0;
                 
                 draw_x = x+r;
                 draw_y = y;         
                 op_x = r;
                 op_y = 0;
                 while(1)
                 {  /* 计算下一点 */
                    op_y++;
                    draw_y--;
                    if( (2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0 )  // 使用逐点比较法实现画圆弧
                    {  op_x--;
                       draw_x--;
                    }
                    if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
                    pno_angle++;
                    if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
                    {  draw_on = 1-draw_on;
                       if(draw_on==1) GUI_Point(draw_x, draw_y, color);
                    } 
                    if(op_y>=op_x)
                    {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);
                       break;
                    }
                 }
                 
                 while(1)
                 {  /* 计算下一点 */
                    op_x--;
                    draw_x--;
                    if( (2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0 ) // 使用逐点比较法实现画圆弧
                    {  op_y++;
                       draw_y--;
                    }
                    if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
                    pno_angle++;
                    if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
                    {  draw_on = 1-draw_on;
                       if(draw_on==1) GUI_Point(draw_x, draw_y, color);
                    } 
                    
                    if(op_x<=0)
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 25  

                    {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);   // 开始画图
                       break;
                    }
                 }
                  
                  
                 /* 开始顺时针画弧，从269度开始(第3像限) */
                 draw_y = y-r;
                 draw_x = x;         
                 op_y = r;
                 op_x = 0;
                 while(1)
                 {  /* 计算下一点 */
                    op_x++;
                    draw_x--;
                    if( (2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_y +1)>0 ) // 使用逐点比较法实现画圆弧
                    {  op_y--;
                       draw_y++;
                    }
                    if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
                    pno_angle++;
                    if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
                    {  draw_on = 1-draw_on;
                       if(draw_on==1) GUI_Point(draw_x, draw_y, color);
                    } 
                    
                    if(op_x>=op_y)
                    {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);   // 开始画图
                       break;
                    }
                 }
                 
                 while(1)
                 {  /* 计算下一点 */
                    op_y--;
                    draw_y++;
                    if( (2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_x +1)<=0 ) // 使用逐点比较法实现画圆弧
                    {  op_x++;
                       draw_x--;
                    }
                    if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
                    pno_angle++;
                    if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
                    {  draw_on = 1-draw_on;
                       if(draw_on==1) GUI_Point(draw_x, draw_y, color);
                    } 
                    if(op_y<=0)
                    {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);
                       break;
                    }
                 }
                 
                 
                 /* 开始顺时针画弧，从179度开始(第2像限) */
                 draw_x = x-r;
                 draw_y = y;         
                 op_x = r;
                 op_y = 0;
                 while(1)
                 {  /* 计算下一点 */
                    op_y++;
                    draw_y++;
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 26  

                    if( (2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0 )  // 使用逐点比较法实现画圆弧
                    {  op_x--;
                       draw_x++;
                    }
                    if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
                    pno_angle++;
                    if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
                    {  draw_on = 1-draw_on;
                       if(draw_on==1) GUI_Point(draw_x, draw_y, color);
                    } 
                    if(op_y>=op_x)
                    {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);
                       break;
                    }
                 }
                 
                 while(1)
                 {  /* 计算下一点 */
                    op_x--;
                    draw_x++;
                    if( (2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0 ) // 使用逐点比较法实现画圆弧
                    {  op_y++;
                       draw_y++;
                    }
                    if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
                    pno_angle++;
                    if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
                    {  draw_on = 1-draw_on;
                       if(draw_on==1) GUI_Point(draw_x, draw_y, color);
                    } 
                    
                    if(op_x<=0)
                    {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);   // 开始画图
                       break;
                    }
                 }
                
                
                 /* 开始顺时针画弧，从89度开始(第1像限) */
                 draw_y = y+r;
                 draw_x = x;         
                 op_y = r;
                 op_x = 0;
                 while(1)
                 {  /* 计算下一点 */
                    op_x++;
                    draw_x++;
                    if( (2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_y +1)>0 ) // 使用逐点比较法实现画圆弧
                    {  op_y--;
                       draw_y--;
                    }
                    if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
                    pno_angle++;
                    if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
                    {  draw_on = 1-draw_on;
                       if(draw_on==1) GUI_Point(draw_x, draw_y, color);
                    } 
                    
                    if(op_x>=op_y)
                    {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);   // 开始画图
                       break;
                    }
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 27  

                 }
                 
                 while(1)
                 {  /* 计算下一点 */
                    op_y--;
                    draw_y--;
                    if( (2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_x +1)<=0 ) // 使用逐点比较法实现画圆弧
                    {  op_x++;
                       draw_x++;
                    }
                    if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
                    pno_angle++;
                    if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
                    {  draw_on = 1-draw_on;
                       if(draw_on==1) GUI_Point(draw_x, draw_y, color);
                    } 
                    if(op_y<=0)
                    {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);
                       break;
                    }
                 }
                 
              }
              #endif
1629          
1630          
1631          
1632          
1633          #if  GUI_Pieslice_EN==1
1634          /****************************************************************************
1635          * 名称：GUI_Pieslice()
1636          * 功能：指定起点、终点及半径扇形(不能画圆)。使用的是顺时针方向画图。
1637          * 入口参数： x      圆心的x轴坐标值
1638          *           y     圆心的y轴坐标值
1639          *           stangle   起始角度(0-359度)
1640          *           endangle  终止角度(0-359度)
1641          *           r       圆的半径终点
1642          *           color   显示颜色
1643          * 出口参数：无
1644          * 说明：操作失败原因是指定地址超出有效范围。
1645          ****************************************************************************/
1646          void  GUI_Pieslice(uint32 x, uint32 y, uint32 r, uint32 stangle, uint32 endangle, TCOLOR color)
1647          {  int32  draw_x, draw_y;         // 画图坐标变量
1648   1         int32  op_x, op_y;           // 操作坐标
1649   1         int32  op_2rr;             // 2*r*r值变量
1650   1         
1651   1         int32  pno_angle;            // 度角点的个数
1652   1         uint8  draw_on;              // 画点开关，为1时画点，为0时不画
1653   1         
1654   1         
1655   1         /* 参数过滤 */
1656   1         if(r==0) return;             // 半径为0则直接退出
1657   1         if(stangle==endangle) return;      // 起始角度与终止角度相同，退出
1658   1         if( (stangle>=360) || (endangle>=360) ) return;
1659   1      
1660   1         op_2rr = 2*r*r;              // 计算r平方乖以2
1661   1         pno_angle = 0;
1662   1         /* 先计算出在此半径下的45度的圆弧的点数 */       
1663   1         op_x = r;
1664   1         op_y = 0;
1665   1         while(1)
1666   1         {  pno_angle++;              // 画点计数         
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 28  

1667   2            /* 计算下一点 */
1668   2            op_y++;
1669   2            if( (2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0 )  // 使用逐点比较法实现画圆弧
1670   2            {  op_x--;
1671   3            }
1672   2            if(op_y>=op_x) break;
1673   2         }
1674   1         
1675   1         draw_on = 0;               // 最开始关画点开关
1676   1         /* 设置起始点及终点 */
1677   1         if(endangle>stangle) draw_on = 1;    // 若终点大于起点，则从一开始即画点(359)
1678   1         stangle = (360-stangle)*pno_angle/45;
1679   1         endangle = (360-endangle)*pno_angle/45;
1680   1         if(stangle==0) stangle=1;
1681   1         if(endangle==0) endangle=1;
1682   1         
1683   1         /* 开始顺时针画弧，从359度开始(第4像限) */
1684   1         pno_angle = 0;
1685   1         
1686   1         draw_x = x+r;
1687   1         draw_y = y;         
1688   1         op_x = r;
1689   1         op_y = 0;
1690   1         while(1)
1691   1         {  /* 计算下一点 */
1692   2            op_y++;
1693   2            draw_y--;
1694   2            if( (2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0 )  // 使用逐点比较法实现画圆弧
1695   2            {  op_x--;
1696   3               draw_x--;
1697   3            }
1698   2            if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
1699   2            pno_angle++;
1700   2            if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
1701   2            {  draw_on = 1-draw_on;
1702   3               if(draw_on==1) GUI_Point(draw_x, draw_y, color);
1703   3               GUI_Line(x, y, draw_x, draw_y, color);
1704   3            } 
1705   2            if(op_y>=op_x)
1706   2            {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);
1707   3               break;
1708   3            }
1709   2         }
1710   1         
1711   1         while(1)
1712   1         {  /* 计算下一点 */
1713   2            op_x--;
1714   2            draw_x--;
1715   2            if( (2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0 ) // 使用逐点比较法实现画圆弧
1716   2            {  op_y++;
1717   3               draw_y--;
1718   3            }
1719   2            if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
1720   2            pno_angle++;
1721   2            if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
1722   2            {  draw_on = 1-draw_on;
1723   3               if(draw_on==1) GUI_Point(draw_x, draw_y, color);
1724   3               GUI_Line(x, y, draw_x, draw_y, color);
1725   3            } 
1726   2            
1727   2            if(op_x<=0)
1728   2            {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);   // 开始画图
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 29  

1729   3               break;
1730   3            }
1731   2         }
1732   1          
1733   1          
1734   1         /* 开始顺时针画弧，从269度开始(第3像限) */
1735   1         draw_y = y-r;
1736   1         draw_x = x;         
1737   1         op_y = r;
1738   1         op_x = 0;
1739   1         while(1)
1740   1         {  /* 计算下一点 */
1741   2            op_x++;
1742   2            draw_x--;
1743   2            if( (2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_y +1)>0 ) // 使用逐点比较法实现画圆弧
1744   2            {  op_y--;
1745   3               draw_y++;
1746   3            }
1747   2            if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
1748   2            pno_angle++;
1749   2            if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
1750   2            {  draw_on = 1-draw_on;
1751   3               if(draw_on==1) GUI_Point(draw_x, draw_y, color);
1752   3               GUI_Line(x, y, draw_x, draw_y, color);
1753   3            } 
1754   2            
1755   2            if(op_x>=op_y)
1756   2            {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);   // 开始画图
1757   3               break;
1758   3            }
1759   2         }
1760   1         
1761   1         while(1)
1762   1         {  /* 计算下一点 */
1763   2            op_y--;
1764   2            draw_y++;
1765   2            if( (2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_x +1)<=0 ) // 使用逐点比较法实现画圆弧
1766   2            {  op_x++;
1767   3               draw_x--;
1768   3            }
1769   2            if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
1770   2            pno_angle++;
1771   2            if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
1772   2            {  draw_on = 1-draw_on;
1773   3               if(draw_on==1) GUI_Point(draw_x, draw_y, color);
1774   3               GUI_Line(x, y, draw_x, draw_y, color);
1775   3            } 
1776   2            if(op_y<=0)
1777   2            {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);
1778   3               break;
1779   3            }
1780   2         }
1781   1         
1782   1         
1783   1         /* 开始顺时针画弧，从179度开始(第2像限) */
1784   1         draw_x = x-r;
1785   1         draw_y = y;         
1786   1         op_x = r;
1787   1         op_y = 0;
1788   1         while(1)
1789   1         {  /* 计算下一点 */
1790   2            op_y++;
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 30  

1791   2            draw_y++;
1792   2            if( (2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0 )  // 使用逐点比较法实现画圆弧
1793   2            {  op_x--;
1794   3               draw_x++;
1795   3            }
1796   2            if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
1797   2            pno_angle++;
1798   2            if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
1799   2            {  draw_on = 1-draw_on;
1800   3               if(draw_on==1) GUI_Point(draw_x, draw_y, color);
1801   3               GUI_Line(x, y, draw_x, draw_y, color);
1802   3            } 
1803   2            if(op_y>=op_x)
1804   2            {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);
1805   3               break;
1806   3            }
1807   2         }
1808   1         
1809   1         while(1)
1810   1         {  /* 计算下一点 */
1811   2            op_x--;
1812   2            draw_x++;
1813   2            if( (2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0 ) // 使用逐点比较法实现画圆弧
1814   2            {  op_y++;
1815   3               draw_y++;
1816   3            }
1817   2            if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
1818   2            pno_angle++;
1819   2            if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
1820   2            {  draw_on = 1-draw_on;
1821   3               if(draw_on==1) GUI_Point(draw_x, draw_y, color);
1822   3               GUI_Line(x, y, draw_x, draw_y, color);
1823   3            } 
1824   2            
1825   2            if(op_x<=0)
1826   2            {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);   // 开始画图
1827   3               break;
1828   3            }
1829   2         }
1830   1        
1831   1        
1832   1         /* 开始顺时针画弧，从89度开始(第1像限) */
1833   1         draw_y = y+r;
1834   1         draw_x = x;         
1835   1         op_y = r;
1836   1         op_x = 0;
1837   1         while(1)
1838   1         {  /* 计算下一点 */
1839   2            op_x++;
1840   2            draw_x++;
1841   2            if( (2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_y +1)>0 ) // 使用逐点比较法实现画圆弧
1842   2            {  op_y--;
1843   3               draw_y--;
1844   3            }
1845   2            if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
1846   2            pno_angle++;
1847   2            if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
1848   2            {  draw_on = 1-draw_on;
1849   3               if(draw_on==1) GUI_Point(draw_x, draw_y, color);
1850   3               GUI_Line(x, y, draw_x, draw_y, color);
1851   3            } 
1852   2            
C51 COMPILER V9.52.0.0   GUI_BASIC                                                         01/01/2020 23:07:04 PAGE 31  

1853   2            if(op_x>=op_y)
1854   2            {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);   // 开始画图
1855   3               break;
1856   3            }
1857   2         }
1858   1         
1859   1         while(1)
1860   1         {  /* 计算下一点 */
1861   2            op_y--;
1862   2            draw_y--;
1863   2            if( (2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_x +1)<=0 ) // 使用逐点比较法实现画圆弧
1864   2            {  op_x++;
1865   3               draw_x++;
1866   3            }
1867   2            if(draw_on==1) GUI_Point(draw_x, draw_y, color);      // 开始画图
1868   2            pno_angle++;
1869   2            if( (pno_angle==stangle)||(pno_angle==endangle) )     // 若遇到起点或终点，画点开关取反
1870   2            {  draw_on = 1-draw_on;
1871   3               if(draw_on==1) GUI_Point(draw_x, draw_y, color);
1872   3               GUI_Line(x, y, draw_x, draw_y, color);
1873   3            } 
1874   2            if(op_y<=0)
1875   2            {  if(draw_on==1) GUI_Point(draw_x, draw_y, color);
1876   3               break;
1877   3            }
1878   2         }
1879   1         
1880   1      }
1881          #endif
1882          
1883          
1884          
1885          
1886          
1887          
1888          
1889          
1890          
1891          
1892          
1893          
1894          
1895          
1896          
1897          
1898          
1899          
1900          
1901          
1902          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  10385    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----     262
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
